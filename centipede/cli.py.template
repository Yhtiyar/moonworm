# Code generated by moonstream centipede : https://github.com/bugout-dev/centipede
# Centipede version : {centipede_version}

import argparse
import json
from typing import Any, Callable, Dict, List, Optional, Tuple
import os

from eth_typing.evm import Address, ChecksumAddress
import web3
from web3 import Web3
from web3.contract import Contract

from .web3_util import *

abi_path = os.path.join(os.path.dirname(__file__), "abi.json")
with open(abi_path, "r") as abi_file:
    CONTRACT_ABI = json.load(abi_file)

CONTRACT_FUNCTIONS = {{}}
for abi_item in CONTRACT_ABI:
    if abi_item["type"] == "function":
        CONTRACT_FUNCTIONS[abi_item["name"]] = abi_item

def init_web3(ipc_path: str) -> Web3:
    return Web3(web3.HTTPProvider(ipc_path))


def init_contract(web3: Web3, abi: Dict[str, Any], address: Optional[str]) -> Contract:
    checksum_address: Optional[ChecksumAddress] = None
    if address is not None:
        checksum_address = web3.toChecksumAddress(address)
    return web3.eth.contract(address=checksum_address, abi=abi)

def make_function_call(contract: Contract, function_name: str, *args):
    return contract.functions[function_name](*args).call()


def python_type(evm_type: str) -> Callable:
    if evm_type.startswith(("uint", "int")):
        return int
    elif evm_type.startswith("bytes"):
        return bytes
    elif evm_type == "string":
        return str
    elif evm_type == "address":
        return str
    elif evm_type == "bool":
        return bool
    else:
        raise ValueError(f"Cannot convert to python type", evm_type)


{cli_content}

def populate_subparser_with_common_args(
    leaf_parser: argparse.ArgumentParser,
) -> None:
    leaf_parser.add_argument(
        "-w3",
        "--web3",
        required=True,
        help=f"Web3 IPC connection",
    )

    leaf_parser.add_argument(
        "-ca",
        "--contract_address",
        required=True,
        help=f"contract_address",
    )

def handle_args(args: argparse.Namespace):
    # Initializng contract
    web3 = init_web3(args.web3)
    contract_address = web3.toChecksumAddress(args.contract_address)
    contract = web3.eth.contract(address=contract_address, abi=CONTRACT_ABI)
   
    kwargs = vars(args)

    if args.subcommand == "call":
        function_name = kwargs["function_name"]
        del kwargs["function_name"]
        call_args = [
            python_type(f_arg["type"])(kwargs[f_arg["name"]])
            for f_arg in CONTRACT_FUNCTIONS[function_name]["inputs"]
        ]
        print(make_function_call(contract, function_name, *call_args))


def main() -> None:
    parser = generate_argument_parser()
    args = parser.parse_args()
    handle_args(args)


if __name__ == "__main__":
    main()