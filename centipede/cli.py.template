# Code generated by moonstream centipede : https://github.com/bugout-dev/centipede
# Centipede version : {centipede_version}

import argparse
import json
from typing import Any, Callable, Dict, List, Optional, Tuple

from eth_typing.evm import Address, ChecksumAddress
import web3
from web3 import Web3
from web3.contract import Contract

{contract_functions}

def init_web3(ipc_path: str) -> Web3:
    return Web3(web3.HTTPProvider(ipc_path))


def init_contract(web3: Web3, abi: Dict[str, Any], address: Optional[str]) -> Contract:
    checksum_address: Optional[ChecksumAddress] = None
    if address is not None:
        checksum_address = web3.toChecksumAddress(address)
    return web3.eth.contract(address=checksum_address, abi=abi)


def load_abi():
    with open("{abi_json}", "r") as ifp:
        abi = json.load(ifp)
    return abi

def make_function_call(contract: Contract, function_name: str, *args):
    return contract.functions[function_name](*args).call()


def python_type(evm_type: str) -> Callable:
    if evm_type.startswith(("uint", "int")):
        return int
    elif evm_type.startswith("bytes"):
        return bytes
    elif evm_type == "string":
        return str
    elif evm_type == "address":
        return str
    elif evm_type == "bool":
        return bool
    else:
        raise ValueError(f"Cannot convert to python type", evm_type)


{cli_content}

def populate_subparser_with_common_args(
    leaf_parser: argparse.ArgumentParser,
) -> None:
    leaf_parser.add_argument(
        "-web3",
        "--web3",
        required=True,
        help=f"Web3 IPC connection",
    )

    leaf_parser.add_argument(
        "-ca",
        "--contract_address",
        required=True,
        help=f"contract_address",
    )

def handle_args(args: argparse.Namespace):
    # Initializng contract
    web3 = init_web3(args.web3)
    contract_address = web3.toChecksumAddress(args.contract_address)
    abi = load_abi()
    contract = web3.eth.contract(address=contract_address, abi=abi)
   
    kwargs = vars(args)

    if args.subcommand == "call":
        function_name = kwargs["function_name"]
        del kwargs["function_name"]
        call_args = [
            python_type(f_arg["type"])(kwargs[f_arg["name"]])
            for f_arg in CONTRACT_FUNCTIONS[function_name]["inputs"]
        ]
        print(make_function_call(contract, function_name, *call_args))


def main() -> None:
    parser = generate_argument_parser()
    args = parser.parse_args()
    handle_args(args)


if __name__ == "__main__":
    main()